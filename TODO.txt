# TODO List for Symbolic Circuit Solver Project

## I. Core Solver (`symbolic_solver.py`) Enhancements:

1.  **Advanced Inconsistency/Redundancy Diagnostics:**
    *   Provide user-friendly feedback about conflicting equations/constraints.
    *   Inform user about redundant equations in consistent over-determined systems.
    *   [Stretch Goal] Explore symbolic matrix rank analysis for formal system property determination.
2.  **Improved "Unknowns" Handling:**
    *   Investigate more intelligent deduction of intermediate variables if only primary unknowns are specified.
    *   More explicit handling/messaging when user tries to solve for a known (substituted) variable.
3.  **Advanced Simplification of Solutions:**
    *   Allow user-specified simplification strategies (simplify, expand, factor, collect, cse).
    *   Optionally apply assumptions (real, positive) during simplification.
4.  **Units Handling:**
    *   [Major Feature] Integrate a units library (e.g., `pint`) for unit tracking, conversion, and consistency checks.

## II. Component Definitions (`symbolic_components.py`) Extensions:

1.  **Refined AC Power Calculations:**
    *   Add attributes/methods for true Complex Power (S = V*I_conj), Average Real Power (P), Reactive Power (Q), Apparent Power (|S|).
2.  **Non-Linear Components:**
    *   Basic Diode model (ideal or exponential).
3.  **Mutual Inductors / Transformers (K-element).**
4.  **Improved Current Control Specification for CCVS/CCCS:**
    *   Allow passing the controlling component *instance* (not just name) for direct access to its `I_comp`.

## III. SPICE Parser (`spice_parser.py`) Enhancements:

1.  **Subcircuit (`.SUBCKT`) Support.**
2.  **`.MODEL` Statement Support** (for diodes, transistors, etc.).
3.  **Advanced Analysis Command Parsing:**
    *   `.DC` sweeps (parameter sweeps).
    *   `.AC` sweeps (LIN, DEC, OCT with frequency ranges).
    *   [Stretch Goal] `.TRAN` (for time-domain).
    *   Extract parameters from these to guide the solver.
4.  **Error Reporting:** More detailed parsing error messages with line numbers.
5.  **Case Insensitivity:** Ensure fully SPICE-compliant case insensitivity.
6.  **Global Nodes** (e.g., `!GLOBAL GND VCC`).
7.  **Expression Values:** Allow component values to be expressions in terms of parameters (e.g., `R1 N1 N2 {R_val * 2}`).

## IV. Utilities (`utils.py`) & User Interface:

1.  **Graphical Node Map:**
    *   Optionally generate graphical output using `graphviz` or `matplotlib`.
2.  **Plotting for AC Analysis:**
    *   Utilities for Bode plots (magnitude/phase of transfer functions vs. frequency).
3.  **Expression Count Utility (Formalized):**
    *   Callable function `get_system_counts(equations, symbols)` returning dict/string.
4.  **GUI:** (Very Long-Term) Graphical circuit entry and results visualization.

## V. General Solver & Codebase:

1.  **Comprehensive Regression Test Suite:**
    *   Dedicated test files for different modules and features.
    *   Automated testing for preventing regressions.
2.  **Documentation:**
    *   Expand inline docstrings.
    *   [Stretch Goal] Generate project documentation (Sphinx, MkDocs).
3.  **Performance for Large Symbolic Systems:**
    *   Investigate strategies for managing complexity and solution time for larger circuits.
4.  **Handling of Disconnected Circuit Portions:**
    *   Detect and correctly inform about or handle (e.g. solve independently if possible) circuits with multiple disconnected subgraphs.

## VI. Schwachstellen (Weak Points) Observed During H-Bridge Task:

1.  **Formula Complexity:** Fully symbolic formulas (e.g., R3 in terms of all R's, U, and constraint targets) can become extremely large and difficult for direct human interpretation. Outputting in terms of key intermediate solved variables (like node voltages) is often more practical, as currently done. Strategies for hierarchical display or user-guided expansion could be explored.
2.  **User Guidance on Overconstrained Systems:** While the solver can detect inconsistencies or find mathematical solutions like negative resistance, it doesn't currently guide the user on *which specific set* of inputs/constraints are causing the issue in an overconstrained numerical problem. This requires more advanced sensitivity or dependency analysis.
3.  **Simplification Limits:** `sympy.simplify()` is powerful but not a silver bullet. Some complex expressions may not reduce to the most intuitive "simplest" form without specific guidance or assumptions.
