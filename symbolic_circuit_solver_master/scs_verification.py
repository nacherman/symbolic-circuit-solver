import sympy
import os
import sys

# Adjust sys.path for direct script execution
script_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(script_dir)
path_to_add = os.path.dirname(project_root)
if path_to_add not in sys.path:
    sys.path.insert(0, path_to_add)

from symbolic_circuit_solver_master import scs_utils
from symbolic_circuit_solver_master import scs_numerical_solver
from symbolic_circuit_solver_master import scs_errors

# Imports needed for the __main__ test block
from symbolic_circuit_solver_master import scs_circuit
from symbolic_circuit_solver_master import scs_parser as scs_parser_module
from symbolic_circuit_solver_master import scs_instance_hier

def verify_node_voltage_formula(
    symbolic_expr,
    target_node_name: str,
    netlist_path: str,
    num_test_sets: int = 5,
    user_param_override_values: dict = None
) -> dict:
    """
    Verifies a symbolic node voltage formula against numerical DC simulations
    across multiple auto-generated test points.

    Args:
        symbolic_expr: The Sympy expression for the node voltage.
        target_node_name (str): The name of the node whose voltage is being verified (e.g., "N_out").
        netlist_path (str): Path to the SPICE netlist file.
        num_test_sets (int): Number of different parameter sets to test.
        user_param_override_values (dict, optional): A dictionary where keys are
            string names of symbols (e.g., "R1_sym") and values are specific
            numerical values to use for those symbols, overriding generated values.

    Returns:
        dict: A summary of the verification, including match status and details.
    """
    if not hasattr(symbolic_expr, 'free_symbols'):
        # If it's not a Sympy expression with free_symbols (e.g., already a number or None)
        # This basic verification is not applicable in the same way.
        # Or, if it's a constant, special handling might be needed.
        # For now, assume it's a Sympy expression.
        print(f"Warning: symbolic_expr does not have free_symbols. Type: {type(symbolic_expr)}")
        free_symbols = set()
    else:
        free_symbols = symbolic_expr.free_symbols

    # Ensure all keys in user_param_override_values correspond to actual free symbols
    # This helps catch typos in override keys.
    valid_override_symbols = set()
    if user_param_override_values:
        for s_name in user_param_override_values.keys():
            found = False
            for sym in free_symbols:
                if sym.name == s_name:
                    valid_override_symbols.add(sym)
                    found = True
                    break
            if not found and free_symbols: # Only warn if there were symbols to override
                 print(f"Warning: Override key '{s_name}' not found in formula's free symbols: {[s.name for s in free_symbols]}. It will be ignored for symbolic eval and might cause issues if not defined in netlist for numerical.")

    # Generate base test points
    # generate_test_points returns dicts with Sympy symbol keys
    list_of_test_param_maps = scs_utils.generate_test_points(free_symbols, num_test_sets)

    mismatches_details = []
    matches_count = 0
    actual_tests_run = 0

    if not list_of_test_param_maps and free_symbols: # No test points generated for a non-constant formula
        print("Warning: No test points generated by generate_test_points, though formula has symbols.")
        # This might happen if num_test_sets is 0.
        return {
            'verified_all': False, # Cannot verify if no tests run
            'total_tests': 0,
            'matches': 0,
            'mismatches_details': [{'error': 'No test points generated for symbolic formula.'}]
        }
    elif not free_symbols and symbolic_expr is not None: # Constant formula
        print(f"Info: Formula is a constant: {symbolic_expr}")
        actual_tests_run = 1
        param_map_for_constant_eval = {} # Empty dict for constant
        if user_param_override_values: # Apply overrides if any (though they won't affect a constant symbolic_expr)
            print(f"Info: Applying user overrides for constant formula check (may not affect symbolic eval): {user_param_override_values}")
            # For numerical solver, provide these overrides if they match .PARAM names
            param_map_for_constant_eval = {k:v for k,v in user_param_override_values.items()}


        symbolic_voltage_eval = scs_utils.evaluate_symbolic_expr(symbolic_expr, {}) # No subs needed for constant
        # Numerical simulation still needs some params if netlist has symbolic .PARAMs
        # Use override values, or small defaults if no overrides/symbols.
        # For a truly constant formula from a fixed netlist, numerical params might not matter for that specific node.
        # However, the netlist itself might have symbolic .PARAMs requiring values.
        numerical_solver_params_for_constant = param_map_for_constant_eval.copy()

        numerical_results = scs_numerical_solver.solve_dc_numerically(netlist_path, numerical_solver_params_for_constant)
        numerical_voltage = None
        if numerical_results and isinstance(numerical_results, dict) and f"V({target_node_name})" in numerical_results:
            numerical_voltage = numerical_results[f"V({target_node_name})"]

        if symbolic_voltage_eval is not None and numerical_voltage is not None:
            if scs_utils.compare_numerical_values(symbolic_voltage_eval, numerical_voltage):
                matches_count = 1
            else:
                mismatches_details.append({
                    'params': 'Constant Formula',
                    'numerical_value': numerical_voltage,
                    'symbolic_eval_value': symbolic_voltage_eval,
                    'note': 'Constant formula verification'
                })
        else:
             mismatches_details.append({
                    'params': 'Constant Formula',
                    'numerical_value': numerical_voltage,
                    'symbolic_eval_value': symbolic_voltage_eval,
                    'note': 'Failed to get both values for constant formula verification'
                })
        num_test_sets = 1 # Only one meaningful test for a constant

    else: # Symbolic formula with free variables
        actual_tests_run = len(list_of_test_param_maps)
        for i, base_param_map_sympy_keys in enumerate(list_of_test_param_maps):
            print(f"\n--- Verifying Test Point Set {i+1}/{actual_tests_run} ---")

            # Prepare params for symbolic evaluation (uses Sympy symbol keys)
            symbolic_eval_params = base_param_map_sympy_keys.copy()

            # Prepare params for numerical solver (needs string keys if netlist params are strings)
            # However, our solve_dc_numerically passes this to get_numerical_dc_value,
            # which does expr.subs(params), so it needs Sympy symbol keys if expr is symbolic.
            # The .PARAM V_in_sym = V_in_sym results in element values being Sympy symbols.
            numerical_solver_params = base_param_map_sympy_keys.copy()

            if user_param_override_values:
                print(f"  Applying overrides: {user_param_override_values}")
                for str_key, fixed_value in user_param_override_values.items():
                    # Update for numerical solver (already has Sympy symbol keys from base_param_map_sympy_keys)
                    # Find the matching Sympy symbol to update the correct key
                    symbol_to_override = None
                    for s in free_symbols: # free_symbols are Sympy symbols
                        if s.name == str_key:
                            symbol_to_override = s
                            break
                    if symbol_to_override:
                        numerical_solver_params[symbol_to_override] = fixed_value
                        symbolic_eval_params[symbol_to_override] = fixed_value
                    else:
                        # This case means user tried to override a symbol not in the formula.
                        # It might be a global circuit param not in this specific formula.
                        # We should still pass it to numerical solver if it's a valid .PARAM name.
                        # For safety, we create a symbol for it if it's not in free_symbols.
                        # This part is tricky: numerical_solver_params should reflect ALL relevant
                        # params for the netlist, not just free_symbols of one expression.
                        # For now, we only work with free_symbols for generation and override.
                        # If user overrides a param NOT in free_symbols, it won't be in symbolic_eval_params
                        # unless we add it. And for numerical_solver_params, if it's a general circuit
                        # param, it should be added with its Sympy symbol key.
                        # Current generate_test_points only includes free_symbols of the expression.
                        # A more robust solution would involve getting all .PARAM symbols from the netlist.
                        print(f"    Note: Override '{str_key}' not in formula's free symbols, applied to numerical solver params using Sympy Symbol if it exists from .PARAM context.")
                        # This is tricky: if str_key isn't in free_symbols, numerical_solver_params won't have it.
                        # We'd need to convert str_key to a Symbol and add it.
                        # For now, user_param_override_values should primarily target symbols in free_symbols.
                        # The current loop structure implies overrides are only for symbols in free_symbols.
                        pass


            current_param_values_str = {str(k): v for k, v in symbolic_eval_params.items()}
            print(f"  Testing with parameters: {current_param_values_str}")

            numerical_voltage = None
            symbolic_voltage_eval = None

            try:
                numerical_results = scs_numerical_solver.solve_dc_numerically(netlist_path, numerical_solver_params)
                if numerical_results and isinstance(numerical_results, dict) and f"V({target_node_name})" in numerical_results:
                    numerical_voltage = numerical_results[f"V({target_node_name})"]
                else:
                    print(f"  Warning: Target node '{target_node_name}' not found in numerical results or numerical solve failed.")
                    print(f"  Numerical results: {numerical_results}")


                symbolic_voltage_eval = scs_utils.evaluate_symbolic_expr(symbolic_expr, symbolic_eval_params)

                print(f"  Numerical V({target_node_name}): {numerical_voltage}")
                print(f"  Symbolic Eval V({target_node_name}): {symbolic_voltage_eval}")

                if numerical_voltage is not None and symbolic_voltage_eval is not None:
                    if scs_utils.compare_numerical_values(numerical_voltage, symbolic_voltage_eval):
                        matches_count += 1
                        print("  Status: MATCH")
                    else:
                        mismatches_details.append({
                            'params': current_param_values_str,
                            'numerical_value': numerical_voltage,
                            'symbolic_eval_value': symbolic_voltage_eval
                        })
                        print("  Status: MISMATCH")
                else:
                    mismatches_details.append({
                        'params': current_param_values_str,
                        'numerical_value': numerical_voltage,
                        'symbolic_eval_value': symbolic_voltage_eval,
                        'note': 'One or both evaluation methods failed to produce a value.'
                    })
                    print("  Status: ERROR (one or both evaluations failed)")

            except Exception as e_loop:
                print(f"  ERROR during test point processing: {type(e_loop).__name__}: {e_loop}")
                import traceback
                traceback.print_exc()
                mismatches_details.append({
                    'params': current_param_values_str,
                    'error': str(e_loop)
                })

    return {
        'verified_all': len(mismatches_details) == 0 and matches_count == actual_tests_run and actual_tests_run > 0,
        'total_tests_run': actual_tests_run,
        'matches': matches_count,
        'mismatches': len(mismatches_details),
        'mismatches_details': mismatches_details,
        'target_node': target_node_name,
        'symbolic_formula': str(symbolic_expr)
    }

def verify_element_current_formula(
    symbolic_expr_for_current,
    target_element_name: str,
    netlist_path: str,
    num_test_sets: int = 5,
    user_param_override_values: dict = None
) -> dict:
    """
    Verifies a symbolic element current formula against numerical DC simulations
    across multiple auto-generated test points.

    Args:
        symbolic_expr_for_current: The Sympy expression for the element current.
        target_element_name (str): The name of the element whose current is being verified (e.g., "R1").
        netlist_path (str): Path to the SPICE netlist file.
        num_test_sets (int): Number of different parameter sets to test.
        user_param_override_values (dict, optional): A dictionary where keys are
            string names of symbols and values are specific numerical values.

    Returns:
        dict: A summary of the verification.
    """
    if not hasattr(symbolic_expr_for_current, 'free_symbols'):
        print(f"Warning: symbolic_expr_for_current does not have free_symbols. Type: {type(symbolic_expr_for_current)}")
        free_symbols = set()
    else:
        free_symbols = symbolic_expr_for_current.free_symbols

    if user_param_override_values:
        for s_name in user_param_override_values.keys():
            found = False
            for sym in free_symbols:
                if sym.name == s_name:
                    found = True
                    break
            if not found and free_symbols:
                 print(f"Warning: Override key '{s_name}' not found in formula's free symbols: {[s.name for s in free_symbols]}.")

    list_of_test_param_maps = scs_utils.generate_test_points(free_symbols, num_test_sets)

    mismatches_details = []
    matches_count = 0
    actual_tests_run = 0

    if not list_of_test_param_maps and free_symbols:
        print("Warning: No test points generated for symbolic current formula.")
        return {
            'verified_all': False,
            'total_tests_run': 0,
            'matches': 0,
            'mismatches': 0, # Corrected from mismatches_details
            'mismatches_details': [{'error': 'No test points generated for symbolic current formula.'}],
            'target_element': target_element_name,
            'symbolic_formula': str(symbolic_expr_for_current)
        }
    elif not free_symbols and symbolic_expr_for_current is not None: # Constant formula
        print(f"Info: Current formula is a constant: {symbolic_expr_for_current}")
        actual_tests_run = 1
        param_map_for_constant_eval = {}
        if user_param_override_values:
            print(f"Info: Applying user overrides for constant formula check: {user_param_override_values}")
            param_map_for_constant_eval = {k:v for k,v in user_param_override_values.items()}

        symbolic_current_eval = scs_utils.evaluate_symbolic_expr(symbolic_expr_for_current, {})
        numerical_solver_params_for_constant = param_map_for_constant_eval.copy()

        numerical_results = scs_numerical_solver.solve_dc_numerically(netlist_path, numerical_solver_params_for_constant)
        numerical_current = None
        if numerical_results and isinstance(numerical_results, dict) and 'element_currents' in numerical_results:
            numerical_current = numerical_results['element_currents'].get(target_element_name)

        if symbolic_current_eval is not None and numerical_current is not None:
            if scs_utils.compare_numerical_values(symbolic_current_eval, numerical_current):
                matches_count = 1
            else:
                mismatches_details.append({
                    'params': 'Constant Formula',
                    'numerical_value': numerical_current,
                    'symbolic_eval_value': symbolic_current_eval,
                    'note': 'Constant current formula verification'
                })
        else:
            mismatches_details.append({
                'params': 'Constant Formula',
                'numerical_value': numerical_current,
                'symbolic_eval_value': symbolic_current_eval,
                'note': 'Failed to get both values for constant current formula verification'
            })
        num_test_sets = 1
    else: # Symbolic formula with free variables
        actual_tests_run = len(list_of_test_param_maps)
        for i, base_param_map_sympy_keys in enumerate(list_of_test_param_maps):
            print(f"\n--- Verifying Current Test Point Set {i+1}/{actual_tests_run} for Element {target_element_name} ---")

            symbolic_eval_params = base_param_map_sympy_keys.copy()
            numerical_solver_params = base_param_map_sympy_keys.copy()

            if user_param_override_values:
                print(f"  Applying overrides: {user_param_override_values}")
                for str_key, fixed_value in user_param_override_values.items():
                    symbol_to_override = next((s for s in free_symbols if s.name == str_key), None)
                    if symbol_to_override:
                        numerical_solver_params[symbol_to_override] = fixed_value
                        symbolic_eval_params[symbol_to_override] = fixed_value

            current_param_values_str = {str(k): v for k, v in symbolic_eval_params.items()}
            print(f"  Testing with parameters: {current_param_values_str}")

            numerical_current = None
            symbolic_current_eval = None

            try:
                numerical_results = scs_numerical_solver.solve_dc_numerically(netlist_path, numerical_solver_params)
                if numerical_results and isinstance(numerical_results, dict) and 'element_currents' in numerical_results:
                    numerical_current = numerical_results['element_currents'].get(target_element_name)
                else:
                    print(f"  Warning: Element currents not found in numerical results or numerical solve failed.")
                    print(f"  Numerical results: {numerical_results}")

                symbolic_current_eval = scs_utils.evaluate_symbolic_expr(symbolic_expr_for_current, symbolic_eval_params)

                print(f"  Numerical I({target_element_name}): {numerical_current}")
                print(f"  Symbolic Eval I({target_element_name}): {symbolic_current_eval}")

                if numerical_current is not None and symbolic_current_eval is not None:
                    if scs_utils.compare_numerical_values(numerical_current, symbolic_current_eval):
                        matches_count += 1
                        print("  Status: MATCH")
                    else:
                        mismatches_details.append({
                            'params': current_param_values_str,
                            'numerical_value': numerical_current,
                            'symbolic_eval_value': symbolic_current_eval
                        })
                        print("  Status: MISMATCH")
                else:
                    mismatches_details.append({
                        'params': current_param_values_str,
                        'numerical_value': numerical_current,
                        'symbolic_eval_value': symbolic_current_eval,
                        'note': 'One or both evaluation methods failed to produce a current value.'
                    })
                    print("  Status: ERROR (one or both current evaluations failed)")
            except Exception as e_loop:
                print(f"  ERROR during current test point processing: {type(e_loop).__name__}: {e_loop}")
                import traceback
                traceback.print_exc()
                mismatches_details.append({
                    'params': current_param_values_str,
                    'error': str(e_loop)
                })

    return {
        'verified_all': len(mismatches_details) == 0 and matches_count == actual_tests_run and actual_tests_run > 0,
        'total_tests_run': actual_tests_run,
        'matches': matches_count,
        'mismatches': len(mismatches_details),
        'mismatches_details': mismatches_details,
        'target_element': target_element_name,
        'symbolic_formula': str(symbolic_expr_for_current)
    }

if __name__ == '__main__':
    print("--- Verification Utility Self-Test ---")

    netlist_content_test = """
* Voltage Divider Test for Verification Utility
.PARAM V_in_sym = V_in_sym
.PARAM R1_sym = R1_sym
.PARAM R2_sym = R2_sym

V1 N_in 0 V_in_sym
R1 N_in N_out R1_sym
R2 N_out 0 R2_sym
.end
"""
    temp_file = "temp_verifier_test.sp"
    with open(temp_file, 'w') as f:
        f.write(netlist_content_test)

    # Symbolic derivation part (simplified)
    V_in_s, R1_s, R2_s = sympy.symbols('V_in_sym R1_sym R2_sym')
    # Manually define the expected symbolic expression for V(N_out)
    # In a real scenario, this would come from top_instance.v('N_out', '0')
    # symbolic_expr_test = (V_in_s * R2_s) / (R1_s + R2_s) # Original simple form
    # The solver produces 1.0*... for some reason, let's match that style for self-consistency here
    v_n_out_symbolic_expr_test = (sympy.Float('1.0')*R2_s*V_in_s)/(sympy.Float('1.0')*R1_s + sympy.Float('1.0')*R2_s)

    # For current through R1 (N_in -> N_out): I(R1) = (V(N_in) - V(N_out)) / R1_s
    # V(N_in) is V_in_s
    # So, I(R1) = (V_in_s - V(N_out)) / R1_s
    # I(R1) = (V_in_s - (V_in_s * R2_s) / (R1_s + R2_s)) / R1_s
    # I(R1) = (V_in_s * (1 - R2_s / (R1_s + R2_s))) / R1_s
    # I(R1) = (V_in_s * (R1_s + R2_s - R2_s) / (R1_s + R2_s)) / R1_s
    # I(R1) = (V_in_s * R1_s / (R1_s + R2_s)) / R1_s
    # I(R1) = V_in_s / (R1_s + R2_s)
    # Let's use the form derived from the solver's style for V(N_out)
    # V_N_in_expr = V_in_s # Assuming N_in is directly connected to V_in_s positive terminal relative to ground
    # i_r1_symbolic_expr_test_manual = (V_N_in_expr - v_n_out_symbolic_expr_test) / R1_s
    i_r1_symbolic_expr_test_manual = sympy.simplify((V_in_s - v_n_out_symbolic_expr_test) / R1_s)
    # The symbolic solver might produce it as V_in_sym/(R1_sym + R2_sym) directly
    # For testing, we'll use the one derived from the symbolic V(N_out)
    # Or, better yet, get it from top_instance.i('R1') after solving symbolically.

    # --- Perform Symbolic Solution Once to get expressions ---
    print("\n--- Performing Initial Symbolic Solution for Expressions ---")
    top_circuit_main = scs_circuit.TopCircuit()
    parsed_circuit_main = scs_parser_module.parse_file(temp_file, top_circuit_main)
    if not parsed_circuit_main:
        print("MAIN TEST PARSING FAILED")
        sys.exit(1)
    top_instance_main = scs_instance_hier.make_top_instance(parsed_circuit_main)
    if not top_instance_main:
        print("MAIN TEST INSTANCE CREATION FAILED")
        sys.exit(1)
    top_instance_main.solve()

    v_n_out_actual_expr = top_instance_main.v('N_out', '0')
    i_r1_actual_expr = top_instance_main.i('R1') # Current N_in -> N_out

    print(f"  Derived V(N_out) symbolic: {v_n_out_actual_expr}")
    print(f"  Derived I(R1) symbolic: {i_r1_actual_expr}")


    print(f"\nVerifying Node Voltage formula: {v_n_out_actual_expr} for node N_out")
    verification_results_v = verify_node_voltage_formula(
        v_n_out_actual_expr,
        'N_out',
        temp_file,
        num_test_sets=3
    )
    print("\n--- Node Voltage Verification Summary (Test 1) ---")
    for k, v in verification_results_v.items():
        if k == 'mismatches_details' and v:
            print(f"  {k}:")
            for item in v:
                print(f"    {item}")
        else:
            print(f"  {k}: {v}")

    print("\n--- Node Voltage Verification Summary (Test 2 - with override) ---")
    override_params_v = {'R1_sym': 2000.0}
    print(f"Overriding with: {override_params_v}")
    verification_results_v_override = verify_node_voltage_formula(
        v_n_out_actual_expr,
        'N_out',
        temp_file,
        num_test_sets=3,
        user_param_override_values=override_params_v
    )
    for k, v in verification_results_v_override.items():
        if k == 'mismatches_details' and v:
            print(f"  {k}:")
            for item in v:
                print(f"    {item}")
        else:
            print(f"  {k}: {v}")

    print(f"\nVerifying Element Current formula: {i_r1_actual_expr} for element R1")
    verification_results_i = verify_element_current_formula(
        i_r1_actual_expr,
        'R1',
        temp_file,
        num_test_sets=3
    )
    print("\n--- Element Current Verification Summary (Test 3) ---")
    for k,v in verification_results_i.items():
        if k == 'mismatches_details' and v:
            print(f"  {k}:")
            for item in v:
                print(f"    {item}")
        else:
            print(f"  {k}: {v}")

    if os.path.exists(temp_file):
        os.remove(temp_file)
    print(f"\nCleaned up {temp_file}.")
