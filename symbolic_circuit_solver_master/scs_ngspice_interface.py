# coding: utf-8
"""
NGSpice Netlist Generator from Symbolic Circuit Instance.

This module provides functionality to generate an NGSpice-compatible DC netlist
from a solved symbolic circuit instance and a dictionary of numerical parameter values,
run NGSpice, and parse its output.
"""
import sympy
import typing
import os
import sys
import subprocess # For running NGSpice
import tempfile   # For temporary netlist file
import re         # For parsing NGSpice output

# Path setup: Ensure the project root (parent of symbolic_circuit_solver_master) is in sys.path
# This allows absolute imports like 'from symbolic_circuit_solver_master...' to work reliably
# when the script is run directly.
try:
    current_script_dir_for_path = os.path.dirname(os.path.abspath(__file__))
    project_root_for_path = os.path.dirname(current_script_dir_for_path)
    if project_root_for_path not in sys.path:
        sys.path.insert(0, project_root_for_path)
except NameError:
    print("Warning: __file__ not defined during initial sys.path setup for scs_ngspice_interface.py. Assuming package is accessible.")
    pass

from symbolic_circuit_solver_master import scs_elements as elements
from symbolic_circuit_solver_master import scs_instance_hier as instance_hier
from symbolic_circuit_solver_master import scs_parser as parser_module
from symbolic_circuit_solver_master import scs_circuit as circuit_module


def _sanitize_ngspice_name(name: str, el_obj: elements.Element) -> str:
    """
    Sanitizes an element name for NGSpice compatibility and ensures it starts
    with the correct SPICE letter prefix.
    """
    name = name.replace('.', '_dot_')

    # Determine the correct prefix based on element type
    prefix = ""
    if isinstance(el_obj, elements.Resistance): prefix = 'R'
    elif isinstance(el_obj, elements.VoltageControlledVoltageSource): prefix = 'E'
    elif isinstance(el_obj, elements.CurrentControlledVoltageSource): prefix = 'H'
    elif type(el_obj) is elements.VoltageSource: prefix = 'V' # Must be after E, H
    elif isinstance(el_obj, elements.VoltageControlledCurrentSource): prefix = 'G'
    elif isinstance(el_obj, elements.CurrentControlledCurrentSource): prefix = 'F'
    elif type(el_obj) is elements.CurrentSource: prefix = 'I' # Must be after G, F
    # Add other types (L, C, etc.) as needed

    if prefix and not name.upper().startswith(prefix):
        return prefix + name

    if name and name[0].isalpha(): # Check if first char is a letter
        return name
    elif name: # Does not start with a letter, but not empty
        return 'X' + name # Default prefix for non-alpha starting or unknown
    else: # Empty name, should not happen with valid elements
        return 'X_unnamed_element'


def generate_ngspice_dc_netlist(top_instance: instance_hier.Instance,
                                param_values_num: dict) -> str:
    """
    Generates an NGSpice DC netlist string. (Docstring from previous version)
    """
    netlist_lines = ['* NGSpice DC Netlist generated by scs_ngspice_interface.py']
    netlist_lines.append('* Temperature 25.000000')

    element_lines = []
    print_current_lines = [] # For currents through V, E, H sources

    for el_name_orig, el_obj in top_instance.elements.items():
        num_val = None
        if hasattr(el_obj, 'get_numerical_dc_value'): # Preferred method
            try:
                num_val = el_obj.get_numerical_dc_value(param_values_num)
            except Exception as e:
                print(f"Warning: Error calling get_numerical_dc_value for {el_name_orig}: {e}. Skipping.")
                continue
        elif el_obj.values: # Fallback for elements that might not have get_numerical_dc_value yet
            print(f"Warning: Element {el_name_orig} ({type(el_obj).__name__}) lacks get_numerical_dc_value. Using fallback.")
            val_expr = el_obj.values[0]
            try:
                if isinstance(val_expr, sympy.Expr):
                    num_val_sympy = val_expr.subs(param_values_num).evalf()
                else: # Attempt to sympify then substitute
                    num_val_sympy = sympy.sympify(val_expr).subs(param_values_num).evalf()

                if num_val_sympy.is_Number:
                    num_val = float(num_val_sympy)
                else:
                    print(f"Warning: Fallback value for {el_name_orig} ('{val_expr}') -> '{num_val_sympy}' not fully numerical. Skipping.")
                    continue
            except Exception as e:
                print(f"Warning: Fallback could not process value for {el_name_orig} ('{val_expr}'): {e}. Skipping.")
                continue

        # Skip elements where num_val could not be determined, unless they don't need one (e.g. C, L for DC)
        if num_val is None and not isinstance(el_obj, (elements.Capacitance, elements.Inductance)):
            print(f"Warning: Numerical value for {el_name_orig} not determined. Skipping.")
            continue

        ng_name = _sanitize_ngspice_name(el_obj.names[0], el_obj)
        nodes = el_obj.nets
        line = ""

        if isinstance(el_obj, elements.Resistance):
            if num_val is not None: line = f"{ng_name} {nodes[0]} {nodes[1]} {num_val:.10g}"
        elif type(el_obj) is elements.VoltageSource:
            if num_val is not None:
                line = f"{ng_name} {nodes[0]} {nodes[1]} DC {num_val:.10g}"
                print_current_lines.append(f".PRINT DC I({ng_name})")
        elif type(el_obj) is elements.CurrentSource:
            if num_val is not None: line = f"{ng_name} {nodes[0]} {nodes[1]} DC {num_val:.10g}"
        elif isinstance(el_obj, elements.VoltageControlledVoltageSource):
            if num_val is not None and len(nodes) >= 4:
                line = f"{ng_name} {nodes[0]} {nodes[1]} {nodes[2]} {nodes[3]} {num_val:.10g}"
                print_current_lines.append(f".PRINT DC I({ng_name})")
        elif isinstance(el_obj, elements.VoltageControlledCurrentSource):
            if num_val is not None and len(nodes) >= 4:
                line = f"{ng_name} {nodes[0]} {nodes[1]} {nodes[2]} {nodes[3]} {num_val:.10g}"
        elif isinstance(el_obj, elements.CurrentControlledVoltageSource):
            if num_val is not None and len(el_obj.names) > 1:
                control_vsource_orig_name = el_obj.names[1]
                control_vsource_obj = top_instance.elements.get(control_vsource_orig_name)
                if control_vsource_obj:
                    sanitized_control_name = _sanitize_ngspice_name(control_vsource_obj.names[0], control_vsource_obj)
                    line = f"{ng_name} {nodes[0]} {nodes[1]} {sanitized_control_name} {num_val:.10g}"
                    print_current_lines.append(f".PRINT DC I({ng_name})")
                else:
                    print(f"Warning: Controlling source '{control_vsource_orig_name}' for H-elem '{ng_name}' not found. Skipping.")
                    continue
        elif isinstance(el_obj, elements.CurrentControlledCurrentSource):
            if num_val is not None and len(el_obj.names) > 1:
                control_vsource_orig_name = el_obj.names[1]
                control_vsource_obj = top_instance.elements.get(control_vsource_orig_name)
                if control_vsource_obj:
                    sanitized_control_name = _sanitize_ngspice_name(control_vsource_obj.names[0], control_vsource_obj)
                    line = f"{ng_name} {nodes[0]} {nodes[1]} {sanitized_control_name} {num_val:.10g}"
                else:
                    print(f"Warning: Controlling source '{control_vsource_orig_name}' for F-elem '{ng_name}' not found. Skipping.")
                    continue

        if line:
            element_lines.append(line)
        elif num_val is not None:
            print(f"Note: Element {el_name_orig} of type {type(el_obj).__name__} was processed but no line generated.")

    netlist_lines.extend(element_lines)
    netlist_lines.append(".OPTIONS gmin=1e-12 abstol=1e-9 reltol=1e-6")
    netlist_lines.append(".DC TEMP 25 25 1")
    netlist_lines.append(".OP")
    for net_name in top_instance.nets:
        if net_name != '0':
            netlist_lines.append(f".PRINT DC V({net_name})")
    netlist_lines.extend(print_current_lines)
    netlist_lines.append(".END")
    return "\n".join(netlist_lines)

def run_ngspice_dc(netlist_string: str, ngspice_executable: str = 'ngspice') -> typing.Tuple[str, str, int]:
    """
    Runs an NGSpice DC simulation using a provided netlist string. (Docstring from previous version)
    """
    temp_file_path = None
    try:
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.cir', encoding='utf-8') as temp_file:
            temp_file.write(netlist_string)
            temp_file_path = temp_file.name
        command = [ngspice_executable, '-b', temp_file_path]
        print(f"Running NGSpice command: {' '.join(command)}")
        result = subprocess.run(command, capture_output=True, text=True, check=False)
        return result.stdout, result.stderr, result.returncode
    except FileNotFoundError:
        error_msg = f"Error: NGSpice executable '{ngspice_executable}' not found. Please ensure it is installed and in your PATH."
        print(error_msg)
        return "", error_msg, -1
    except Exception as e:
        error_msg = f"An unexpected error occurred while running NGSpice: {type(e).__name__} - {e}"
        print(error_msg)
        return "", error_msg, -2
    finally:
        if temp_file_path and os.path.exists(temp_file_path):
            os.remove(temp_file_path)
            print(f"Cleaned up temporary NGSpice netlist: {temp_file_path}")

def parse_ngspice_dc_output(ngspice_stdout: str) -> dict:
    """
    Parses the stdout from an NGSpice DC operating point (.OP) simulation
    that used .PRINT statements. (Docstring from previous version)
    """
    results = {'node_voltages': {}, 'vsource_currents': {}, 'element_currents': {}}
    lines = ngspice_stdout.splitlines()
    header_parts, data_parts_float = [], []
    data_line_idx = -1

    for i, line in reversed(list(enumerate(lines))):
        line_stripped = line.strip()
        if not line_stripped: continue
        potential_data_values_str = re.split(r'\s+', line_stripped)
        if not potential_data_values_str or not potential_data_values_str[0]: continue
        try:
            data_parts_float = [float(val) for val in potential_data_values_str]
            data_line_idx = i; break
        except ValueError: continue

    if data_line_idx > 0:
        for i in range(data_line_idx - 1, -1, -1):
            header_line_candidate = lines[i].strip()
            if header_line_candidate: header_parts = re.split(r'\s+', header_line_candidate); break

    if not header_parts or not data_parts_float: # Fallback parsing
        var_idx, val_idx = -1, -1
        for i, line in enumerate(lines):
            if line.strip().lower() == "variables:": var_idx = i
            elif line.strip().lower() == "values:": val_idx = i; break
        if var_idx != -1 and val_idx != -1 and val_idx > var_idx:
            header_parts = [lines[j].strip().split()[0] for j in range(var_idx + 1, val_idx) if lines[j].strip()]
            if val_idx + 1 < len(lines):
                raw_data_str = re.split(r'\s+', lines[val_idx + 1].strip())
                try: data_parts_float = [float(val) for val in raw_data_str]
                except ValueError: header_parts, data_parts_float = [], []
            else: header_parts, data_parts_float = [], []
        else: header_parts, data_parts_float = [], []

    if not header_parts or not data_parts_float or len(header_parts) != len(data_parts_float):
        print(f"Warning: NGSpice output parsing mismatch. Header ({len(header_parts)}): {header_parts}, Data ({len(data_parts_float)}): {data_parts_float}")
        return results

    first_header_lower = header_parts[0].lower()
    if first_header_lower == "index" or "no." in first_header_lower:
        header_parts, data_parts_float = header_parts[1:], data_parts_float[1:]
        if not header_parts or len(header_parts) != len(data_parts_float):
            print("Warning: Header/data mismatch after skipping index."); return results

    for i, name_raw in enumerate(header_parts):
        name_lower, value = name_raw.lower(), data_parts_float[i]
        m_volt = re.fullmatch(r'v\(([^)]+)\)', name_lower)
        if m_volt: results['node_voltages'][m_volt.group(1).upper()] = value; continue

        m_curr_i_dev = re.fullmatch(r'i\(([^)]+)\)', name_lower)
        m_curr_branch = re.fullmatch(r'([^#\s]+)#branch', name_lower)
        parsed_el_name, is_vsource_curr = (m_curr_i_dev.group(1), True) if m_curr_i_dev and m_curr_i_dev.group(1)[0].upper() in ('V','E','H') else \
                                        (m_curr_i_dev.group(1), False) if m_curr_i_dev else \
                                        (m_curr_branch.group(1), True) if m_curr_branch else (None, False)
        if parsed_el_name:
            (results['vsource_currents'] if is_vsource_curr else results['element_currents'])[parsed_el_name.upper()] = value
    return results

if __name__ == '__main__':
    print("--- NGSpice Interface Self-Test ---")
    spice_content = """
* Simple Test Circuit for NGSpice Netlist Generation
V1 n1 0 V1_s
R1 n1 0 R1_s
.PARAM V1_s = V1_s
.PARAM R1_s = R1_s
.end
"""
    temp_source_netlist_path = "_temp_ng_test_circuit.sp"
    temp_generated_ngspice_path = "_temp_generated_ngspice.cir"
    temp_files_to_clean = [temp_source_netlist_path, temp_generated_ngspice_path]

    try:
        with open(temp_source_netlist_path, 'w') as f: f.write(spice_content)
        parsed_circuit_obj = parser_module.parse_file(temp_source_netlist_path, circuit_module.TopCircuit())
        if not parsed_circuit_obj: print("Failed to parse the test SPICE netlist.")
        else:
            top_instance = instance_hier.make_top_instance(parsed_circuit_obj)
            if not top_instance: print("Failed to create circuit instance.")
            else:
                V1_s_sym, R1_s_sym = sympy.symbols('V1_s R1_s')
                param_values = { V1_s_sym: 5.0, R1_s_sym: 100.0 }
                print(f"\nGenerating NGSpice netlist with parameters: {param_values}")
                ngspice_netlist_str = generate_ngspice_dc_netlist(top_instance, param_values)
                print("\n--- Generated NGSpice Netlist ---"); print(ngspice_netlist_str)
                with open(temp_generated_ngspice_path, 'w') as f: f.write(ngspice_netlist_str)
                print(f"\nGenerated NGSpice netlist written to: {temp_generated_ngspice_path}")

                run_actual_ngspice = False
                if run_actual_ngspice:
                    print("\n--- Running NGSpice DC Analysis (Actual Execution) ---")
                    stdout, stderr, retcode = run_ngspice_dc(ngspice_netlist_str)
                    print(f"\nNGSpice Return Code: {retcode}\nNGSpice STDOUT:\n{stdout}")
                    if stderr: print(f"\nNGSpice STDERR:\n{stderr}")
                    if retcode == 0 and stdout:
                        print("\n--- Parsing NGSpice Output (Actual Execution) ---")
                        parsed_data_actual = parse_ngspice_dc_output(stdout)
                        print(f"Parsed data from actual run: {parsed_data_actual}")
                else:
                    print("\n--- Skipping Actual NGSpice Execution ---")

                print("\n--- Testing NGSpice Output Parser with Sample Data ---")
                sample_stdout_op_batch = "Index   v(n1)           v1#branch\n0	5.000000e+00	-5.000000e-02"
                sample_stdout_op_direct_print = "v(n1)           i(v1)\n5.000000e+00    -5.000000e-02"

                print(f"\nTesting with sample_stdout_op_batch:\n{sample_stdout_op_batch}")
                parsed_data1 = parse_ngspice_dc_output(sample_stdout_op_batch)
                print(f"Parsed (batch): {parsed_data1}")
                assert abs(parsed_data1['node_voltages'].get('N1',0) - 5.0) < 1e-9, "V(N1) mismatch"
                assert abs(parsed_data1['vsource_currents'].get('V1',0) - (-0.05)) < 1e-9, "I(V1) mismatch"
                print("Batch sample parsed OK.")

                print(f"\nTesting with sample_stdout_op_direct_print:\n{sample_stdout_op_direct_print}")
                parsed_data2 = parse_ngspice_dc_output(sample_stdout_op_direct_print)
                print(f"Parsed (direct): {parsed_data2}")
                assert abs(parsed_data2['node_voltages'].get('N1',0) - 5.0) < 1e-9, "V(N1) mismatch"
                assert abs(parsed_data2['vsource_currents'].get('V1',0) - (-0.05)) < 1e-9, "I(V1) mismatch"
                print("Direct print sample parsed OK.")

    except Exception as e:
        print(f"An error occurred during the self-test: {type(e).__name__} - {e}")
        import traceback
        traceback.print_exc()
    finally:
        print("\nCleaning up temporary files...")
        for f_path in temp_files_to_clean:
            if os.path.exists(f_path): os.remove(f_path); print(f"  Removed {f_path}")
        print("Self-test finished.")
